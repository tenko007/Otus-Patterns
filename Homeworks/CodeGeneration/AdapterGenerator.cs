using System;
using System.IO;
using System.Reflection;
using System.Text;
using Tanks_Game_Core;
using System.Linq.Expressions;
using CodeGeneration.SaveAndLoad;

using Microsoft.CSharp;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace CodeGeneration
{
    [Generator]
    public class AdapterGenerator : ISourceGenerator
    {
        private static Type _type;
        public string FilePath(Type type)
        {
            DirectoryInfo directoryInfo = Directory.CreateDirectory("..");//Directory.GetCurrentDirectory());
            return directoryInfo.Parent.Parent.Parent.ToString() 
                   + $"\\CodeGeneration\\AutoGenerated\\{type.Name}Adapter.cs";
        }
        
        public IMovable Generate(Type type)
        {
            _type = type;
            string classText = GenerateClass(type);

            var constantExpression = Expression.Constant(classText);
            Expression classExpression = Expression.Block(constantExpression);
            //var parameterExpression = Expression.Parameter(typeof(Type), type.ToString());
            
            //var expression = Expression.Lambda<Action<Type>>(classExpression, parameterExpression);
            var expression = Expression.Lambda<Action>(classExpression);
            
            var classCompiled = expression.Compile();
            return (IMovable)classCompiled.DynamicInvoke();

            //classCompiled.Invoke(type);
            //classCompiled.Invoke();
            
            
            //var adapterType = Type.GetType($"{type}Adapter");
            var adapterType = Type.GetType("IMovableAdapter");
            
            
            AssemblyName assemblyName = new AssemblyName($"{type}Adapter");  
            //AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(this.asemblyName, AssemblyBuilderAccess.Run); 

            
            var adapterInstance = Activator.CreateInstance(adapterType);
            return (IMovable) adapterInstance;
        }

        public object GetAdapter(Type type)
        {
            CSharpCodeProvider compiler = new CSharpCodeProvider();
            
            CompilerParameters parameters = new CompilerParameters();
            parameters.CompilerOptions = "/optimize + ";

            CompilerResults results = compiler
                .CompileAssemblyFromSource(parameters, GenerateClass(type));

            Type adapter = results
                .CompiledAssembly.GetType("TypeAdapter");

            return Activator.CreateInstance(adapter);

            /*
            MethodInfo method = serializationHelper.GetMethod("XmlSerialize");

            Serializer = (Func<T, string>)Delegate
                .CreateDelegate(typeof(Func<T, string>), method);

            return Serializer;
            */
            return null;
        }
        
        public void GenerateCSFile(Type type)
        {
            string classText = GenerateClass(type);
            SaveAndLoadFile.SaveFile(classText, FilePath(type));
        }

        public string GenerateClass(Type type)
        {
            StringBuilder builder = new StringBuilder();
            
            builder.AppendLine($"//This class was autogenerated at {DateTime.Now}");
            builder.AppendLine($"using System;");
            builder.AppendLine($"public class {type.Name}Adapter : {type}");
            builder.AppendLine("{");
            builder.AppendLine($"{typeof(GameObject)} obj;");
            builder.AppendLine($"public {type.Name}Adapter({typeof(GameObject)} obj) {{ this.obj = obj; }} ");

            GenerateCtor(type, builder);
            
            var methods = type.GetMethods();
            foreach (var method in methods)
                GenerateMethod(type, method, builder);
            
            builder.AppendLine("}");
            return builder.ToString();
        }

        public void GenerateCtor(Type type, StringBuilder builder)
        {
            builder.AppendLine("public IMovableAdapter() { }");
        }
        
        public void GenerateMethod(Type type, MethodInfo methodInfo, StringBuilder builder)
        {
            string methodType = methodInfo.Name.Substring(0, 3);
            string attribute = methodInfo.Name.Substring(3);

            string parameterType = methodInfo.ReturnType.ToString();
            if (methodInfo.ReturnType == typeof(void)) parameterType = "void"; // ReturnType returns System.Void that cause an error
            
            builder.Append($"public {parameterType} {methodInfo.Name}(");
            GenerateParameters(methodInfo, builder);
            
            builder.Append(")\n{");

            if (methodType == "set")
                builder.AppendLine($"\nreturn IoC.Resolve<{methodInfo.ReturnType}>(\"{type.Name}.{attribute}.set\", obj, " +
                                   $"{methodInfo.GetParameters()[0].Name});");
            else if (methodType == "get")
                builder.AppendLine($"\nreturn IoC.Resolve<{methodInfo.ReturnType}>(\"{type.Name}.{attribute}\", obj);");
            else
                builder.Append(TryGetCurrentMethodRealization(methodInfo.Name, type));
            
            builder.AppendLine("}");
        }
        
        public void GenerateParameters(MethodInfo methodInfo, StringBuilder builder)
        {
            var parameters = methodInfo.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                builder.Append($"{parameters[i].ParameterType} {parameters[i].Name}");
                if (i < parameters.Length - 1)
                    builder.Append(", ");
            }
        }
        
        private string TryGetCurrentMethodRealization(string methodName, Type type)
        {
            string filePath = FilePath(type);
            string fileText = SaveAndLoadFile.ReadFile(filePath);
            
            if (fileText.Contains(methodName))
            {
                int methodStart = fileText.IndexOf(methodName);
                methodStart = fileText.IndexOf("{", methodStart);
                int methodEnd = FindEndOfMethod(fileText, methodStart);
                return fileText.Substring(methodStart + 1, (methodEnd - 1) - methodStart);
            }

            return "throw new NotImplementedException();";
        }
        
        public int FindEndOfMethod(string fileText, int methodStart)
        {
            int methodEnd = fileText.IndexOf("}", methodStart);
            int fileLength = fileText.Length;

            int unclosed = 1;
            for (int i = methodStart + 1; i < fileLength; i++)
            {
                if (fileText[i] == '{')
                    unclosed++;
                if (fileText[i] == '}')
                    unclosed--;

                if (unclosed == 0)
                    return i;
            }
            return methodEnd;
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // инициализация здесь не требуется 
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // код, который мы будем внедрять в компиляцию пользователя
            var classText = GenerateClass(typeof(IMovable));
            // внедрим созданный исходник в компиляцию пользователя
            //context.AddSource($"{_type}Adapter.cs", SourceText.From(classText, Encoding.UTF8));
            context.AddSource("IMovableAdapter", SourceText.From(classText, Encoding.UTF8));
        }
    }
}